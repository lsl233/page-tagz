// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// --- 用户模型 (对应 users 表) ---
model User {
  id        Int       @id @default(autoincrement()) // 主键，自增整数 (对应 PostgreSQL 的 SERIAL)
  name      String    @unique                     // 用户名，唯一且非空 (对应 TEXT NOT NULL UNIQUE)
  email     String    @unique                     // 邮箱，唯一且非空 (对应 TEXT NOT NULL UNIQUE)
  password  String                                // 密码哈希，非空 (对应 TEXT NOT NULL)

  // 时间戳字段，使用 @default(now()) 设置创建时间，@updatedAt 设置更新时间
  createdAt DateTime  @default(now()) @map("created_at") // 对应 created_at 列
  updatedAt DateTime  @updatedAt @map("updated_at")     // 对应 updated_at 列

  // Relations: 一个用户有很多书签 (One-to-Many)
  // Prisma 会根据 Bookmark 模型中的 userId 外键自动识别这个关系
  bookmarks Bookmark[]

  // @map("users") 将模型名称 'User' 映射到数据库中的表名 'users'
  @@map("users")
}

// --- 书签模型 (对应 bookmarks 表) ---
model Bookmark {
  id          Int       @id @default(autoincrement()) // 主键，自增整数
  userId      Int       @map("user_id")              // 外键，关联到 User 模型

  url         String                                // 网页 URL，非空
  title       String?                               // 网页标题，可选 (对应 TEXT NULLABLE)
  description String?                               // 描述，可选 (对应 TEXT NULLABLE)

  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")

  // Relations:
  // 一个书签属于一个用户 (Many-to-One)
  // @relation 定义了 Many-to-One 关系，fields 指向本模型的外键字段，references 指向目标模型的主键字段
  // onDelete: Cascade 对应数据库外键的级联删除行为
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  // 一个书签有很多 BookmarkTag 关联记录 (One-to-Many 到中间表)
  // 这是实现 Many-to-Many 的一部分
  bookmarkTags BookmarkTag[]

  // Constraints:
  // @@unique([userId, url]) 定义一个联合唯一约束，确保同一个用户下 URL 唯一
  @@unique([userId, url])
  // @map("bookmarks") 将模型名称 'Bookmark' 映射到数据库中的表名 'bookmarks'
  @@map("bookmarks")
}

// --- 标签模型 (对应 tags 表) ---
model Tag {
  id        Int       @id @default(autoincrement()) // 主键，自增整数
  name      String    @unique                     // 标签名称，唯一且非空

  createdAt DateTime  @default(now()) @map("created_at")
  updatedAt DateTime  @updatedAt @map("updated_at")

  // Relations:
  // 一个标签有很多 BookmarkTag 关联记录 (One-to-Many 到中间表)
  // 这是实现 Many-to-Many 的一部分
  bookmarkTags BookmarkTag[]

  // @map("tags") 将模型名称 'Tag' 映射到数据库中的表名 'tags'
  @@map("tags")
}

// --- 书签与标签的关联模型 (对应 bookmark_tags 中间表) ---
// 这个模型代表了书签和标签之间的 Many-to-Many 关联关系
model BookmarkTag {
  // 外键字段，关联到 Bookmark 和 Tag 模型
  bookmarkId Int @map("bookmark_id") // 对应数据库中的 bookmark_id 列
  tagId      Int @map("tag_id")      // 对应数据库中的 tag_id 列

  createdAt  DateTime @default(now()) @map("created_at")

  // Relations:
  // 一条关联记录属于一个书签 (Many-to-One)
  bookmark   Bookmark @relation(fields: [bookmarkId], references: [id], onDelete: Cascade)

  // 一条关联记录属于一个标签 (Many-to-One)
  tag        Tag      @relation(fields: [tagId], references: [id], onDelete: Cascade)

  // Constraints:
  // @@id([bookmarkId, tagId]) 定义一个联合主键，确保同一个书签和标签的组合唯一
  @@id([bookmarkId, tagId])
  // @map("bookmark_tags") 将模型名称 'BookmarkTag' 映射到数据库中的表名 'bookmark_tags'
  @@map("bookmark_tags")
}
